---
title: 😵‍💫跟力扣斗智斗勇-log-1
password: ""
tags:
  - LeetCode
  - 算法
  - 数据结构
  - 面试
katex: true
comments: true
aside: true
date: 2022-03-09 13:20:05
cover: https://www.helloimg.com/images/2022/03/09/RCFDqX.png
top_img:
---

# 跟力扣斗智斗勇-log

<!--
 * @?: *********************************************************************
 * @Author: Weidows
 * @LastEditors: Weidows
 * @LastEditTime: 2022-03-31 22:39:27
 * @FilePath: \Blog-private\source\_posts\public-post\LeetCode\1.md
 * @Description:
 * @!: *********************************************************************
-->

```pullquote mindmap mindmap-md
- [跟力扣斗智斗勇-log](#跟力扣斗智斗勇-log)
  - [数据结构与算法](#数据结构与算法)
    - [链表反转问题](#链表反转问题)
    - [素数](#素数)
    - [二叉树前中后序遍历](#二叉树前中后序遍历)
  - [题解](#题解)
    - [160. 相交链表](#160-相交链表)
  - [方法](#方法)
    - [投票算法](#投票算法)
  - [坑](#坑)
    - [python-取整与整除](#python-取整与整除)
  - [借物表](#借物表)
```

[⏩ 文章地址](https://weidows.github.io/post/public-post/LeetCode/1/) | [✔️ 仓库地址](https://github.com/Weidows-projects/public-post) 欢迎提交 pr !

一题二写，三数之和，题解四瞅五瞄六瞧，水平还七上八下九流，十分辣鸡\
十天九考，八皇会面，题干七页六道五问，答案仅四行三言两语，一点不会

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 数据结构与算法

课程: 速览 ing

{% mmedia "bilibili" "bvid:BV1a54y1b74k" %}

### 链表反转问题

`迭代(栈)` / `递归`

这问题我面试时问我了,我回答的就是栈,面试官说栈要遍历两次,而递归一次就能出(函数参数添加 prev 节点)

---

### 素数

非素数(合数) / 素数(质数) : 都要排除 0 和 1

- 暴力法: 遍历 2 到 $\sqrt{n}$ 之前的数字,如果能被整除,那么这个数字不是素数

  ```java
  for(int i = 2; i * i < x; i++){}
  ```

- 埃塞法: 比如找 100 内有多少个素数 (25 个)

  构造 bool[100]

  找到 3 是素数, 那么 3x3=3, 3x4=12, 3x5=15...3x33=99 都不是素数,对应 bool[i]做标记,遍历时跳过

---

### 二叉树前中后序遍历

- 基本上是递归模板,比如中序遍历 BST 如下:

  ```java
    public void inOrder(TreeNode root) {
      if (root == null)
        return;
      inOrder(root.left);
      bstQueue.offer(root.val);
      inOrder(root.right);
    }
  ```

  详见这个题解: https://github.com/Weidows-projects/public-post/blob/main/LeetCode/code/173.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8.java

- 前后序遍历: <sup id='cite_ref-3'>[\[3\]](#cite_note-3)</sup>

  ```java
    public void inOrder(TreeNode root) {
      if (root == null)
        return;
      bstQueue.offer(root.val);
      inOrder(root.left);
      inOrder(root.right);
    }
  ```

  ```java
    public void inOrder(TreeNode root) {
      if (root == null)
        return;
      inOrder(root.left);
      inOrder(root.right);
      bstQueue.offer(root.val);
    }
  ```

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 题解

### 160. 相交链表

> https://github.com/Weidows-projects/public-post/blob/main/LeetCode/code/160.%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.py

- 此方法简单描述就是交叉接尾
  <sup id='cite_ref-1'>[\[1\]](#cite_note-1)</sup>

  ```python
  class Solution(object):
      def getIntersectionNode(self, headA, headB):
          """
          :type head1, head1: ListNode
          :rtype: ListNode
          """
          p, q = headA, headB
          while p != q:
              p = p.next if p else headB
              q = q.next if q else headA
          return p
  ```

  ![](https://www.helloimg.com/images/2022/03/09/RCFKPP.png)

  ![](https://www.helloimg.com/images/2022/03/09/RCFg7n.png)

  当前链表结尾后接上对方链表的头, 同时以两链表头为起点, 可以发现都走了 7 步后在交叉绿点相遇

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 方法

### 投票算法

可以看一下多数元素的题解 <sup id='cite_ref-2'>[\[2\]](#cite_note-2)</sup>

对于出现次数$n$大于$\frac{n}{2}$的元素,能抵消其他元素还有余量,最后 candidate 必然是众数

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 坑

### python-取整与整除

```python
# 整除: 对于正数是int(), 对于负数是round()
print(3//2)          # 1
print(-3//2)         # -2
print(9//5)          # 1
print(-9//5)         # -2
# 向下取整
print(int(3 / 2))    # 1
print(int(-3 / 2))   # -1
# 四舍五入
print(round(3 / 2))  # 2
print(round(-3 / 2)) # -2
# 还有其他区别
print(int(14 - 3 / 2))  # 12 (14-1.5=12.5 -> 12)
print(int(14 - 3 // 2)) # 13 (14-1=13)
print(int(- 3 / 2))     # -1 (-1.5 -> -1)
print(int(-3 // 2))     # -2
```

<a>![分割线](https://cdn.jsdelivr.net/gh/Weidows/Images/img/divider.png)</a>

## 借物表

<a name='cite_note-1' href='#cite_ref-1'>[1]</a>: https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/

<a name='cite_note-2' href='#cite_ref-2'>[2]</a>: https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/

<a name='cite_note-3' href='#cite_ref-3'>[3]</a>: https://blog.csdn.net/u013834525/article/details/80421684
